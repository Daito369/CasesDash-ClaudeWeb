<script>
/**
 * Edit Case Modal Module
 *
 * Handles editing of case data through a modal dialog
 * Implements form validation, API integration, and accessibility features
 *
 * @author CasesDash v3.0.0
 */

// Global state for Edit Case Modal
let editingCaseId = null;
let editingSheetName = null;
let editingRowIndex = null;
let originalCaseData = null;
let editingIrtData = null;
let editModalFocusTrap = null;

/**
 * Open edit case modal
 * @param {string} caseId - Case ID to edit
 * @param {string} sheetName - Sheet name where the case is located
 * @param {number} rowIndex - Row index of the case in the sheet
 */
function editCase(caseId, sheetName, rowIndex) {
  console.log('Opening edit case modal for:', caseId, 'from sheet:', sheetName, 'row:', rowIndex);

  editingCaseId = caseId;
  editingSheetName = sheetName;
  editingRowIndex = rowIndex;
  const modal = document.getElementById('editCaseModal');

  // Show modal
  modal.style.display = 'flex';

  // Set up keyboard listeners
  setupEditModalKeyboardListeners();

  // Set up keyboard shortcuts for date/time inputs
  setupEditModalKeyboardShortcuts();

  // Set up focus trap
  setupEditModalFocusTrap();

  // Load case data
  loadCaseForEdit(caseId, sheetName, rowIndex);
}

/**
 * Close edit case modal
 */
function closeEditCaseModal() {
  console.log('Closing edit case modal');

  const modal = document.getElementById('editCaseModal');
  modal.style.display = 'none';

  // Clean up
  editingCaseId = null;
  editingSheetName = null;
  editingRowIndex = null;
  originalCaseData = null;
  editingIrtData = null;
  teardownEditModalKeyboardListeners();
  teardownEditModalKeyboardShortcuts();
  teardownEditModalFocusTrap();

  // Reset form
  document.getElementById('editCaseForm').reset();
  document.getElementById('editCaseForm').style.display = 'none';
  document.getElementById('editCaseLoading').style.display = 'flex';
  document.getElementById('editCaseError').style.display = 'none';

  // Remove validation classes
  document.querySelectorAll('.form-control').forEach(el => {
    el.classList.remove('is-invalid', 'is-valid');
  });
}

/**
 * Load case data for editing
 * @param {string} caseId - Case ID
 * @param {string} sheetName - Sheet name
 * @param {number} rowIndex - Row index of the case
 */
async function loadCaseForEdit(caseId, sheetName, rowIndex) {
  console.log('Loading case data for editing:', caseId, 'from sheet:', sheetName, 'row:', rowIndex);

  // Show loading state
  document.getElementById('editCaseLoading').style.display = 'flex';
  document.getElementById('editCaseForm').style.display = 'none';
  document.getElementById('editCaseError').style.display = 'none';

  try {
    // Call backend API with sheetName and rowIndex to get the correct case
    const result = await API.cases.get(caseId, sheetName, rowIndex);

    if (!result) {
      throw new Error('No response from server');
    }

    if (!result.success) {
      throw new Error(result.error || 'Failed to load case data');
    }

    console.log('Case data loaded for editing:', result);

    // Store original data, sheet name, and IRT data
    originalCaseData = result.case;
    editingSheetName = result.sheetName;
    editingIrtData = result.irtData;

    // Hide loading, show form
    document.getElementById('editCaseLoading').style.display = 'none';
    document.getElementById('editCaseForm').style.display = 'block';

    // Populate form with data including IRT data for reopen count
    populateEditForm(result.case, result.sheetName, result.irtData);

  } catch (error) {
    console.error('Error loading case for edit:', error);

    // Show error state
    document.getElementById('editCaseLoading').style.display = 'none';
    document.getElementById('editCaseError').style.display = 'block';
    document.getElementById('editCaseError').textContent =
      `Failed to load case data: ${error.message}`;
  }
}

/**
 * Populate edit form with case data
 * @param {Object} caseData - Case data
 * @param {string} sheetName - Sheet name
 * @param {Object} irtData - IRT data (optional)
 */
function populateEditForm(caseData, sheetName, irtData) {
  // Read-only context information
  document.getElementById('editCaseId').textContent = caseData.caseId;
  document.getElementById('editSheet').textContent = sheetName;

  const caseOpenedText = `${caseData.caseOpenDate || ''} ${caseData.caseOpenTime || ''}`.trim();
  document.getElementById('editCaseOpened').textContent = caseOpenedText || 'N/A';

  document.getElementById('editFirstAssignee').textContent = caseData.firstAssignee || 'N/A';

  const incomingSegmentEl = document.getElementById('editIncomingSegment');
  incomingSegmentEl.textContent = caseData.incomingSegment || 'N/A';
  incomingSegmentEl.setAttribute('data-segment', caseData.incomingSegment || '');

  document.getElementById('editProductCategory').textContent = caseData.productCategory || 'N/A';

  // Editable fields - Status & Assignment
  document.getElementById('inputCaseStatus').value = caseData.caseStatus || 'Assigned';
  document.getElementById('inputFinalAssignee').value = caseData.finalAssignee || '';
  document.getElementById('inputFinalSegment').value = caseData.finalSegment || caseData.incomingSegment || 'Gold';

  // Editable fields - Flags
  document.getElementById('inputTriage').checked = Boolean(caseData.triage);
  document.getElementById('inputAmInitiated').checked = Boolean(caseData.amInitiated);
  document.getElementById('inputIs30').checked = Boolean(caseData.is30);
  document.getElementById('inputMcc').checked = Boolean(caseData.mcc);
  document.getElementById('inputChangeToChild').checked = Boolean(caseData.changeToChild);
  document.getElementById('inputBugL2').checked = Boolean(caseData.bugL2);

  // Hide AM Initiated checkbox for non-Email sheets
  const amInitiatedCheckbox = document.getElementById('amInitiatedCheckbox');
  if (sheetName && !sheetName.includes('Email')) {
    amInitiatedCheckbox.style.display = 'none';
  } else {
    amInitiatedCheckbox.style.display = 'flex';
  }

  // Editable fields - Transfer & Disposition
  document.getElementById('inputAmTransfer').value = caseData.amTransfer || '';
  document.getElementById('inputNonNcc').value = caseData.nonNCC || '';

  // Editable fields - Close Date/Time
  // Determine if this is a reopen case based on IRT data
  const reopenCount = irtData ? (irtData.reopenCount || 0) : 0;
  const isReopen = reopenCount > 0;

  // Get current date and time for defaults
  const now = new Date();
  const currentDate = formatDateForInput(now);
  const currentTime = formatTimeForInput(now);

  // Update labels based on reopen status
  if (isReopen) {
    document.getElementById('closeDateTimeTitle').textContent = 'Reopen Close Date & Time';
    document.getElementById('closeDateLabel').textContent = 'Reopen Close Date';
    document.getElementById('closeTimeLabel').textContent = 'Reopen Close Time';

    // Set values for reopen close (default to current date/time if not set)
    document.getElementById('inputCloseDate').value = caseData.reopenCloseDate
      ? formatSheetDateForInput(caseData.reopenCloseDate)
      : currentDate;
    document.getElementById('inputCloseTime').value = caseData.reopenCloseTime
      ? formatSheetTimeForInput(caseData.reopenCloseTime)
      : currentTime;
  } else {
    document.getElementById('closeDateTimeTitle').textContent = '1st Close Date & Time';
    document.getElementById('closeDateLabel').textContent = '1st Close Date';
    document.getElementById('closeTimeLabel').textContent = '1st Close Time';

    // Set values for first close (default to current date/time if not set)
    document.getElementById('inputCloseDate').value = caseData.firstCloseDate
      ? formatSheetDateForInput(caseData.firstCloseDate)
      : currentDate;
    document.getElementById('inputCloseTime').value = caseData.firstCloseTime
      ? formatSheetTimeForInput(caseData.firstCloseTime)
      : currentTime;
  }
}

/**
 * Format date string from sheet to HTML date input format (YYYY-MM-DD)
 * Converts YYYY/MM/DD to YYYY-MM-DD
 * @param {string} date - Date string (YYYY/MM/DD or YYYY-MM-DD)
 * @return {string} Formatted date for input
 */
function formatSheetDateForInput(date) {
  if (!date) return '';
  // Convert YYYY/MM/DD to YYYY-MM-DD
  return String(date).replace(/\//g, '-');
}

/**
 * Format time string for HTML time input (HH:MM:SS)
 * @param {string} time - Time string
 * @return {string} Formatted time for input
 */
function formatSheetTimeForInput(time) {
  if (!time) return '';
  return String(time);
}

/**
 * Format Date object to date string for HTML date input (YYYY-MM-DD)
 * Used for keyboard shortcuts and default values (works with Date objects)
 * @param {Date} date - Date object
 * @return {string} Formatted date string
 */
function formatDateForInput(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Format Date object to time string for HTML time input (HH:MM:SS)
 * Used for keyboard shortcuts and default values (works with Date objects)
 * @param {Date} date - Date object
 * @return {string} Formatted time string
 */
function formatTimeForInput(date) {
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
}

/**
 * Validate edit form
 * @return {Object} Validation result { valid: boolean, errors: Object }
 */
function validateEditForm() {
  const errors = {};
  let isValid = true;

  // Case Status - required
  const caseStatus = document.getElementById('inputCaseStatus').value.trim();
  if (!caseStatus) {
    errors.caseStatus = 'Case Status is required';
    isValid = false;
  }

  // Final Assignee - required, LDAP format
  const finalAssignee = document.getElementById('inputFinalAssignee').value.trim();
  if (!finalAssignee) {
    errors.finalAssignee = 'Final Assignee is required';
    isValid = false;
  } else if (finalAssignee.includes('@')) {
    errors.finalAssignee = 'Enter LDAP only (without @google.com)';
    isValid = false;
  } else if (!/^[a-zA-Z0-9]+$/.test(finalAssignee)) {
    errors.finalAssignee = 'LDAP should contain only letters and numbers';
    isValid = false;
  }

  // Final Segment - required
  const finalSegment = document.getElementById('inputFinalSegment').value.trim();
  if (!finalSegment) {
    errors.finalSegment = 'Final Segment is required';
    isValid = false;
  }

  // Apply validation feedback to form
  applyValidationFeedback('inputCaseStatus', errors.caseStatus);
  applyValidationFeedback('inputFinalAssignee', errors.finalAssignee);
  applyValidationFeedback('inputFinalSegment', errors.finalSegment);

  return { valid: isValid, errors };
}

/**
 * Apply validation feedback to form field
 * @param {string} fieldId - Field ID
 * @param {string} errorMessage - Error message (null if valid)
 */
function applyValidationFeedback(fieldId, errorMessage) {
  const field = document.getElementById(fieldId);

  if (errorMessage) {
    field.classList.add('is-invalid');
    field.classList.remove('is-valid');

    // Add or update error message
    let feedback = field.nextElementSibling;
    if (!feedback || !feedback.classList.contains('invalid-feedback')) {
      feedback = document.createElement('div');
      feedback.className = 'invalid-feedback';
      field.parentNode.insertBefore(feedback, field.nextSibling);
    }
    feedback.textContent = errorMessage;
  } else {
    field.classList.remove('is-invalid');
    field.classList.add('is-valid');

    // Remove error message
    const feedback = field.nextElementSibling;
    if (feedback && feedback.classList.contains('invalid-feedback')) {
      feedback.remove();
    }
  }
}

/**
 * Save edited case
 */
async function saveEditCase() {
  console.log('Saving edited case:', editingCaseId);

  // Validate form
  const validation = validateEditForm();
  if (!validation.valid) {
    console.warn('Form validation failed:', validation.errors);
    showToast('Please fix validation errors', 'error');
    return;
  }

  // Collect form data
  const updates = {
    caseStatus: document.getElementById('inputCaseStatus').value.trim(),
    finalAssignee: document.getElementById('inputFinalAssignee').value.trim(),
    finalSegment: document.getElementById('inputFinalSegment').value.trim(),
    triage: document.getElementById('inputTriage').checked,
    amInitiated: document.getElementById('inputAmInitiated').checked,
    is30: document.getElementById('inputIs30').checked,
    mcc: document.getElementById('inputMcc').checked,
    changeToChild: document.getElementById('inputChangeToChild').checked,
    bugL2: document.getElementById('inputBugL2').checked,
    amTransfer: document.getElementById('inputAmTransfer').value.trim(),
    nonNCC: document.getElementById('inputNonNcc').value.trim()
  };

  // Add Close Date/Time based on reopen status
  const reopenCount = editingIrtData ? (editingIrtData.reopenCount || 0) : 0;
  const isReopen = reopenCount > 0;

  const closeDate = document.getElementById('inputCloseDate').value;
  const closeTime = document.getElementById('inputCloseTime').value;

  if (isReopen) {
    // This is a reopen case, update reopen close fields
    updates.reopenCloseDate = closeDate ? closeDate.replace(/-/g, '/') : null;
    updates.reopenCloseTime = closeTime || null;
  } else {
    // This is a first close, update first close fields
    updates.firstCloseDate = closeDate ? closeDate.replace(/-/g, '/') : null;
    updates.firstCloseTime = closeTime || null;
  }

  console.log('Update data:', updates);

  // Show loading state on save button
  const saveBtn = document.getElementById('saveEditBtn');
  saveBtn.disabled = true;
  saveBtn.classList.add('saving');

  try {
    // Call backend API with sheetName and rowIndex to update the correct row
    const result = await API.cases.update(editingCaseId, updates, editingSheetName, editingRowIndex);

    if (!result) {
      throw new Error('No response from server');
    }

    if (!result.success) {
      throw new Error(result.error || 'Failed to update case');
    }

    console.log('Case updated successfully:', result);

    // Show success message
    showToast('Case updated successfully!', 'success');

    // Close modal
    closeEditCaseModal();

    // Refresh the cases list if we're on My Cases page
    if (typeof refreshMyCases === 'function') {
      setTimeout(() => {
        refreshMyCases();
      }, 500);
    }

  } catch (error) {
    console.error('Error updating case:', error);
    showToast(`Failed to update case: ${error.message}`, 'error');
  } finally {
    // Reset button state
    saveBtn.disabled = false;
    saveBtn.classList.remove('saving');
  }
}

/**
 * Show toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'success', 'error', 'warning', 'info'
 * @param {number} duration - Duration in milliseconds (default: 3000)
 */
function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer');
  if (!container) {
    console.warn('Toast container not found, falling back to alert');
    alert(message);
    return;
  }

  // Create toast element
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;

  // Icon mapping
  const icons = {
    success: 'check_circle',
    error: 'error',
    warning: 'warning',
    info: 'info'
  };

  toast.innerHTML = `
    <div class="toast-icon">
      <span class="material-icons">${icons[type] || icons.info}</span>
    </div>
    <div class="toast-message">${message}</div>
    <button class="toast-close" onclick="this.parentElement.remove()">
      <span class="material-icons">close</span>
    </button>
  `;

  // Add to container
  container.appendChild(toast);

  // Auto-remove after duration
  setTimeout(() => {
    toast.classList.add('hiding');
    setTimeout(() => {
      if (toast.parentElement) {
        toast.remove();
      }
    }, 300); // Wait for animation to complete
  }, duration);
}

/**
 * Setup keyboard listeners for edit modal
 */
function setupEditModalKeyboardListeners() {
  document.addEventListener('keydown', handleEditModalKeyDown);
}

/**
 * Teardown keyboard listeners
 */
function teardownEditModalKeyboardListeners() {
  document.removeEventListener('keydown', handleEditModalKeyDown);
}

/**
 * Handle keyboard events in edit modal
 * @param {KeyboardEvent} event - Keyboard event
 */
function handleEditModalKeyDown(event) {
  // ESC key closes modal
  if (event.key === 'Escape') {
    closeEditCaseModal();
  }
}

/**
 * Setup focus trap for accessibility
 */
function setupEditModalFocusTrap() {
  const modal = document.getElementById('editCaseModal');
  const focusableElements = modal.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );

  if (focusableElements.length === 0) return;

  const firstElement = focusableElements[0];
  const lastElement = focusableElements[focusableElements.length - 1];

  // Focus first element
  firstElement.focus();

  // Trap focus within modal
  editModalFocusTrap = function(event) {
    if (event.key !== 'Tab') return;

    if (event.shiftKey) {
      // Shift + Tab
      if (document.activeElement === firstElement) {
        event.preventDefault();
        lastElement.focus();
      }
    } else {
      // Tab
      if (document.activeElement === lastElement) {
        event.preventDefault();
        firstElement.focus();
      }
    }
  };

  modal.addEventListener('keydown', editModalFocusTrap);
}

/**
 * Teardown focus trap
 */
function teardownEditModalFocusTrap() {
  if (editModalFocusTrap) {
    const modal = document.getElementById('editCaseModal');
    modal.removeEventListener('keydown', editModalFocusTrap);
    editModalFocusTrap = null;
  }
}

/**
 * Setup keyboard shortcuts for Close Date/Time inputs
 * Ctrl+; inserts today's date
 * Ctrl+Shift+; inserts current time
 */
function setupEditModalKeyboardShortcuts() {
  const dateInput = document.getElementById('inputCloseDate');
  const timeInput = document.getElementById('inputCloseTime');

  if (dateInput) {
    dateInput.addEventListener('keydown', handleCloseDateKeyDown);
  }

  if (timeInput) {
    timeInput.addEventListener('keydown', handleCloseTimeKeyDown);
  }
}

/**
 * Teardown keyboard shortcuts
 */
function teardownEditModalKeyboardShortcuts() {
  const dateInput = document.getElementById('inputCloseDate');
  const timeInput = document.getElementById('inputCloseTime');

  if (dateInput) {
    dateInput.removeEventListener('keydown', handleCloseDateKeyDown);
  }

  if (timeInput) {
    timeInput.removeEventListener('keydown', handleCloseTimeKeyDown);
  }
}

/**
 * Handle keyboard events for Close Date input
 * @param {KeyboardEvent} event - Keyboard event
 */
function handleCloseDateKeyDown(event) {
  // Ctrl+; sets today's date
  if (event.ctrlKey && event.key === ';') {
    event.preventDefault();
    const today = new Date();
    event.target.value = formatDateForInput(today);
    console.log('Today\'s date inserted:', event.target.value);
  }
}

/**
 * Handle keyboard events for Close Time input
 * @param {KeyboardEvent} event - Keyboard event
 */
function handleCloseTimeKeyDown(event) {
  // Ctrl+Shift+; sets current time (use code instead of key for better compatibility)
  if (event.ctrlKey && event.shiftKey && (event.code === 'Semicolon' || event.key === ':' || event.key === ';')) {
    event.preventDefault();
    const now = new Date();
    event.target.value = formatTimeForInput(now);
    console.log('Current time inserted:', event.target.value);
  }
}

/**
 * Initialize Edit Case Modal module
 */
function initEditCaseModal() {
  console.log('Edit Case Modal module initialized');

  // Add real-time validation listeners
  const finalAssigneeInput = document.getElementById('inputFinalAssignee');
  if (finalAssigneeInput) {
    finalAssigneeInput.addEventListener('blur', function() {
      const value = this.value.trim();
      if (value) {
        if (value.includes('@')) {
          applyValidationFeedback('inputFinalAssignee', 'Enter LDAP only (without @google.com)');
        } else if (!/^[a-zA-Z0-9]+$/.test(value)) {
          applyValidationFeedback('inputFinalAssignee', 'LDAP should contain only letters and numbers');
        } else {
          applyValidationFeedback('inputFinalAssignee', null);
        }
      }
    });
  }
}

// Initialize on load
initEditCaseModal();
</script>
